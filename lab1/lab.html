<HTML><HEAD><TITLE>CS360 -- Lab 1</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<META content="MSHTML 6.00.6000.16525" name=GENERATOR></HEAD>
<BODY bgColor=#ffffff>
<H1>CS360 -- Lab 1</H1>
<LI><A href="http://www.cs.utk.edu/~huangj">Jian Huang</A> 
<LI><A href="http://www.cs.utk.edu/~huangj/cs360/index.html">CS360</A> 
<LI>Url: <A 
href="http://www.cs.utk.edu/~huangj/cs360/360/labs/lab1/lab.html">http://www.cs.utk.edu/~huangj/cs360/360/labs/lab1/lab.html</A> 

<HR>
This is a lab that makes sure that you have red-black trees, dllists and fields 
down. <b>If you are not yet familiar with Dr. Plank's fdr library (or need to brush up on it!), 
read <a href=http://www.cs.utk.edu/~plank/plank/classes/cs360/360/notes/Libfdr/>
Dr. Plank's lecture notes about libfdr</a>.</b>
<P>Your job in this lab is to write the program <B>famtree</B>. <B>Famtree</B> 
takes a description of people and their relationships to one another on standard 
input. These descriptions must be in a special format, which will be described 
below. An example is in the file <A 
href="http://www.cs.utk.edu/~huangj/cs360/360/labs/lab1/fam1"><B>fam1</B></A>, 
which represents a family composed of Bob and Nancy, and their three chidren 
Frank, Lester and Diana. 
<P><B>Famtree</B> takes such a description, and prints out complete information 
on all of the people in the file. This consist of, for each person, their sex 
(if known), their father, mother and children. Therefore <A 
href="http://www.cs.utk.edu/~huangj/cs360/360/labs/lab1/fam1output"><B>fam1output</B></A> 
contains valid output of <B>famtree</B> on <A 
href="http://www.cs.utk.edu/~huangj/cs360/360/labs/lab1/fam1"><B>fam1</B></A>. 
<P>The format of the input file is as follows. Lines must either be blank, or 
have one of following first words: 
<UL>
  <LI><B>PERSON</B>: This specifies a person. Following <B>PERSON</B> is the 
  person's name, which may be any number of words. <B>Famtree</B> should assume 
  that names consist of words with single spaces between them. 
  <LI><B>SEX</B>: This specifies the person's sex. It can be either <B>M</B> or 
  <B>F</B>. 
  <LI><B>FATHER</B>: This specifies the person's father. Following <B>FATHER</B> 
  is the father's name, which may be any number of words. It implies that the 
  father is male. A person may only have one father. 
  <LI><B>MOTHER</B>: This specifies the person's mother. Following <B>MOTHER</B> 
  is the mother's name, which may be any number of words. It implies that the 
  mother is female. A person may only have one mother. 
  <LI><B>FATHER_OF</B>: This specifies that the person is male, and that the 
  specified person is one of the person's children. A person may have any number 
  of children. 
  <LI><B>MOTHER_OF</B>: This specifies that the person is female, and that the 
  specified person is one of the person's children. </LI></UL><B>Famtree</B> has 
two other features. First, it prints out the people in a structured order. That 
is, no person can be printed out until both of their parents have been printed 
out. If this is impossible (as, for example, in <A 
href="http://www.cs.utk.edu/~huangj/cs360/360/labs/lab1/cyclefam"><B>cyclefam</B></A>), 
then <B>famtree</B> identifies this fact. 
<P>The second feature of <B>famtree</B> is that it allows for redundancy, but it 
infers as much as it can. For example, <A 
href="http://www.cs.utk.edu/~huangj/cs360/360/labs/lab1/redundant"><B>redundant</B></A> 
has a few lines that are redundant. For example, line 3 is redundant because 
Fred must be male by virtue of being Joe's father. Moreover, line 7 is redundant 
because line 2 already specified Fred as Joe's father. The file <A 
href="http://www.cs.utk.edu/~huangj/cs360/360/labs/lab1/nonredundant"><B>nonredundant</B></A> 
is the minimal file specifying the same family. 
<HR>

<H2>Working example</H2>A working example of <B>famtree</B> is under <B>~cs360/lab1/</B>. Try it out on the input files in this 
directory. Other input files are: 
<UL>
  <LI><A 
  href="http://www.cs.utk.edu/~huangj/cs360/360/labs/lab1/fam2"><B>fam2</B></A> 
  a more complex family. 
  <LI><A 
  href="http://www.cs.utk.edu/~huangj/cs360/360/labs/lab1/fam3"><B>fam3</B></A> 
  A family with 10 generations of single parents. 
  <LI><A 
  href="http://www.cs.utk.edu/~huangj/cs360/360/labs/lab1/fam4"><B>fam4</B></A> 
  A file with an error in it. 
  <LI><A 
  href="http://www.cs.utk.edu/~huangj/cs360/360/labs/lab1/fam5"><B>fam5</B></A> 
  A file with another error in it. </LI></UL>You should make your output work 
exactly like <B>famtree</B>'s. 
<HR>

<!--
<H2>Partial Credit</H2>You can get 90% credit if you get everything working but 
the test for valid inputs (e.g. the test that shows that <A 
href="http://www.cs.utk.edu/~huangj/cs360/360/labs/lab1/cyclefam"><B>cyclefam</B></A> 
is invalid). 
<P>Getting the output in the correct order is another 20%. Therefore, if you 
write a program that simply prints out all people in some order, but with the 
correct information, then you'll get 70%. 
<HR>
-->

<H2>Help</H2>I'm going to give rather detailed help here. In fact, I basically 
"give away" how to do the lab. This is so that you understand the correct 
structure of the program. If you think you can do this without any help, and 
don't want the answer given away, please don't read this, and have fun! I'd 
recommend that you at least think about how you'd do it with no help before you 
read further. However, if you want some help, read on. 
<P>You will have a <B>struct</B> for a person (mine is called a <B>Person</B>). 
That struct will have the following fields: 
<UL>
  <LI>Name 
  <LI>Sex 
  <LI>Father 
  <LI>Mother 
  <LI>List of children 
  <LI>Some stuff for depth and breadth first traversal. </LI></UL>
<P>Your program will work in three phases: 
<OL>
  <LI><B>Reading the information into the structs.</B> You should have a 
  red-black tree (mine is called <B>people</B>) that contains all the people. It 
  is keyed on each person's name, and the <B>val</B> fields are the persons' 
  <B>Person</B> structs. You use an <B>IS</B> to read standard input. 
  <P>Each time you read a line that has a name (i.e. <B>PERSON</B>, 
  <B>FATHER</B>, <B>MOTHER</B>, <B>FATHER_OF</B> and <B>MOTHER_OF</B>) you test 
  to see if the person with that name is in the <B>people</B> tree. If not, you 
  create the struct and insert it. 
  <P>Whenever you process a line that needs to create some links (i.e. 
  <B>FATHER</B>, <B>MOTHER</B>, <B>FATHER_OF</B> and <B>MOTHER_OF</B>), you 
  first check to see if the link exists and is correct. If incorrect, you flag 
  an error. If correct, you do nothing. If the link doesn't exist, you should 
  create it in both the parent and the child. 
  <P>When you're done with this phase, you'll have a red-black tree with all 
  people in it, and all the people will have the correct links to their parents 
  and children. </P>
  <LI><B>Testing the graph for cycles.</B> The graph is messed up if there is a 
  cycle in it. In other words, if a person can be his/her own ancestor or 
  descendant, than there is a problem. Testing for cycles is a simple 
  depth-first search, which you should have learned in CS302. To test if a 
  person is his/her own descendant, the following pseudocode will work: <PRE>     /* assume that there is an integer field called "visited" 
        in the Person struct, and that this field is initialized 
        to zero for all people */

     is_descendant(Person *p)
     {
       if (p-&gt;visited == 1) return 0;  /* I.e. we've processed this 
                                               person before and he/she's ok */
       if (p-&gt;visited == 2) return 1;  /* I.e. the graph is messed up */
       p-&gt;visited = 2;
       for all children of p do {
         if is_descendant(child) return 1;
       }
       p-&gt;visited = 1;
       return 0;
     }
</PRE>
  <LI><B>Printing out the graph.</B> If you want to forego the final 20% of the 
  lab, just traverse the <B>people</B> tree and print out each person. 
  Otherwise, this is a kind of breadth-first search. What you do is create a 
  queue (which will be a <B>Dllist</B> called <B>toprint</B>. You can initially 
  put all people into <B>toprint</B>, or you can just put all people who have no 
  parents. 
  <P>Then you execute a loop that does the following: <PRE>/* assume that there is an integer field called "printed" 
   in the Person struct, and that this field is initialized 
   to zero for all people */
 
while toprint is not empty
  take p off the head of toprint
  if p has not been printed, then 
    if p doesn't have parents, or if p's parents have been printed then
      print p
      for all of p's children, put the child at the end of doprint
    end if
  end if
end while
</PRE></LI></OL>Enjoy! 
<HR>
There is a makefile for this lab also under <A 
href="http://www.cs.utk.edu/~cs360/huang/lab1/makefile"><B>http:// 
www.cs.utk.edu/~cs360/huang/lab1/</B></A> </LI></BODY></HTML>
